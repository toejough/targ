package buildtool

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	iofs "io/fs"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
)

type GenerateOptions struct {
	Dir        string
	BuildTag   string
	OnlyTagged bool
}

func GenerateFunctionWrappers(filesystem FileSystem, opts GenerateOptions) (string, error) {
	dir := opts.Dir
	if dir == "" {
		dir = "."
	}
	tag := opts.BuildTag
	if opts.OnlyTagged && tag == "" {
		tag = "targ"
	}

	entries, err := filesystem.ReadDir(dir)
	if err != nil {
		return "", err
	}
	sort.Slice(entries, func(i, j int) bool {
		return entries[i].Name() < entries[j].Name()
	})

	fset := token.NewFileSet()
	packageName := ""
	functions := make(map[string]functionDoc)
	typeNames := make(map[string]bool)
	subcommandNames := make(map[string]bool)
	var parsedFiles int
	needsContextImport := false

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		if !strings.HasSuffix(name, ".go") || strings.HasSuffix(name, "_test.go") {
			continue
		}
		if strings.HasPrefix(name, "generated_targ_") {
			continue
		}

		fullPath := filepath.Join(dir, name)
		content, err := filesystem.ReadFile(fullPath)
		if err != nil {
			return "", err
		}
		if opts.OnlyTagged && !hasBuildTag(content, tag) {
			continue
		}

		parsed, err := parser.ParseFile(fset, fullPath, content, parser.ParseComments)
		if err != nil {
			return "", err
		}
		parsedFiles++
		if packageName == "" {
			packageName = parsed.Name.Name
		} else if packageName != parsed.Name.Name {
			return "", fmt.Errorf("multiple package names in %s", dir)
		}

		ctxAliases, ctxDotImport := contextImportInfo(parsed.Imports)
		for _, decl := range parsed.Decls {
			switch node := decl.(type) {
			case *ast.GenDecl:
				for _, spec := range node.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}
					typeNames[typeSpec.Name.Name] = true
					structType, ok := typeSpec.Type.(*ast.StructType)
					if !ok {
						continue
					}
					recordSubcommandRefs(structType, subcommandNames, map[string]bool{})
				}
			case *ast.FuncDecl:
				if node.Recv != nil || !node.Name.IsExported() {
					continue
				}
				if err := validateFunctionSignature(node.Type, ctxAliases, ctxDotImport); err != nil {
					return "", fmt.Errorf("function %s %v", node.Name.Name, err)
				}
				desc := ""
				if node.Doc != nil {
					desc = strings.TrimSpace(node.Doc.Text())
				}
				usesContext := false
				if node.Type.Params != nil && len(node.Type.Params.List) == 1 {
					usesContext = funcParamIsContext(node.Type.Params.List[0].Type, ctxAliases, ctxDotImport)
				}
				if usesContext {
					needsContextImport = true
				}
				functions[node.Name.Name] = functionDoc{
					Name:         node.Name.Name,
					Description:  desc,
					ReturnsError: functionReturnsError(node.Type),
					UsesContext:  usesContext,
				}
			}
		}
	}

	if parsedFiles == 0 {
		return "", fmt.Errorf("no Go files found in %s", dir)
	}

	if packageName == "" {
		return "", fmt.Errorf("package name not found in %s", dir)
	}

	var functionNames []string
	for name := range functions {
		if subcommandNames[camelToKebab(name)] {
			continue
		}
		functionNames = append(functionNames, name)
	}
	sort.Strings(functionNames)

	if len(functionNames) == 0 {
		return "", nil
	}

	for _, name := range functionNames {
		wrapperName := name + "Command"
		if typeNames[wrapperName] {
			return "", fmt.Errorf("generated wrapper %s already exists", wrapperName)
		}
	}

	var buf bytes.Buffer
	if opts.BuildTag != "" {
		buf.WriteString("//go:build ")
		buf.WriteString(opts.BuildTag)
		buf.WriteString("\n\n")
	}
	buf.WriteString("// Code generated by targ. DO NOT EDIT.\n\n")
	buf.WriteString("package ")
	buf.WriteString(packageName)
	buf.WriteString("\n\n")
	if needsContextImport {
		buf.WriteString("import \"context\"\n\n")
	}

	for idx, name := range functionNames {
		if idx > 0 {
			buf.WriteString("\n")
		}
		fn := functions[name]
		wrapperName := name + "Command"

		buf.WriteString("type ")
		buf.WriteString(wrapperName)
		buf.WriteString(" struct{}\n\n")

		buf.WriteString("func (c *")
		buf.WriteString(wrapperName)
		buf.WriteString(") Run(")
		if fn.UsesContext {
			buf.WriteString("ctx context.Context")
		}
		buf.WriteString(")")
		if fn.ReturnsError {
			buf.WriteString(" error")
		}
		buf.WriteString(" {\n")
		if fn.ReturnsError {
			buf.WriteString("\treturn ")
			buf.WriteString(name)
			buf.WriteString("(")
			if fn.UsesContext {
				buf.WriteString("ctx")
			}
			buf.WriteString(")\n")
		} else {
			buf.WriteString("\t")
			buf.WriteString(name)
			buf.WriteString("(")
			if fn.UsesContext {
				buf.WriteString("ctx")
			}
			buf.WriteString(")\n")
		}
		buf.WriteString("}\n\n")

		buf.WriteString("func (c *")
		buf.WriteString(wrapperName)
		buf.WriteString(") Name() string {\n")
		buf.WriteString("\treturn ")
		buf.WriteString(strconv.Quote(name))
		buf.WriteString("\n")
		buf.WriteString("}\n\n")

		if fn.Description != "" {
			buf.WriteString("func (c *")
			buf.WriteString(wrapperName)
			buf.WriteString(") Description() string {\n")
			buf.WriteString("\treturn ")
			buf.WriteString(strconv.Quote(fn.Description))
			buf.WriteString("\n")
			buf.WriteString("}\n\n")
		}
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return "", err
	}

	filename := filepath.Join(dir, fmt.Sprintf("generated_targ_%s.go", packageName))
	if err := filesystem.WriteFile(filename, formatted, iofs.FileMode(0o644)); err != nil {
		return "", err
	}

	return filename, nil
}

type functionDoc struct {
	Name         string
	Description  string
	ReturnsError bool
	UsesContext  bool
}

func functionReturnsError(fnType *ast.FuncType) bool {
	if fnType.Results == nil || len(fnType.Results.List) == 0 {
		return false
	}
	return len(fnType.Results.List) == 1 && isErrorExpr(fnType.Results.List[0].Type)
}
