// Code generated by impgen. DO NOT EDIT.
// impgen:hash:09b853c369cecce0

package core_test

import (
	_imptest "github.com/toejough/imptest"
	core "github.com/toejough/targ/internal/core"
	io "io"
)

type RunEnvImp struct {
	Args            *_imptest.DependencyMethod
	Printf          *RunEnvMockPrintfMethod
	Println         *RunEnvMockPrintlnMethod
	Exit            *RunEnvMockExitMethod
	Stdout          *_imptest.DependencyMethod
	SupportsSignals *_imptest.DependencyMethod
	Getenv          *RunEnvMockGetenvMethod
	Getwd           *_imptest.DependencyMethod
	BinaryName      *_imptest.DependencyMethod
	// Eventually provides async versions of all methods for concurrent code.
	Eventually *RunEnvImpEventually
}

type RunEnvImpEventually struct {
	Args            *_imptest.DependencyMethod
	Printf          *RunEnvMockPrintfMethod
	Println         *RunEnvMockPrintlnMethod
	Exit            *RunEnvMockExitMethod
	Stdout          *_imptest.DependencyMethod
	SupportsSignals *_imptest.DependencyMethod
	Getenv          *RunEnvMockGetenvMethod
	Getwd           *_imptest.DependencyMethod
	BinaryName      *_imptest.DependencyMethod
}

type RunEnvMockArgsCall struct {
	*_imptest.DependencyCall
}

// Return specifies the typed values the mock should return.
func (c *RunEnvMockArgsCall) Return(result0 []string) {
	c.DependencyCall.Return(result0)
}

type RunEnvMockBinaryNameCall struct {
	*_imptest.DependencyCall
}

// Return specifies the typed values the mock should return.
func (c *RunEnvMockBinaryNameCall) Return(result0 string) {
	c.DependencyCall.Return(result0)
}

type RunEnvMockExitArgs struct {
	Code int
}

type RunEnvMockExitCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *RunEnvMockExitCall) GetArgs() RunEnvMockExitArgs {
	raw := c.RawArgs()
	return RunEnvMockExitArgs{
		Code: raw[0].(int),
	}
}

type RunEnvMockExitMethod struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *RunEnvMockExitMethod) ArgsEqual(code int) *RunEnvMockExitCall {
	call := m.DependencyMethod.ArgsEqual(code)
	return &RunEnvMockExitCall{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *RunEnvMockExitMethod) ArgsShould(matchers ...any) *RunEnvMockExitCall {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &RunEnvMockExitCall{DependencyCall: call}
}

type RunEnvMockGetenvArgs struct {
	Key string
}

type RunEnvMockGetenvCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *RunEnvMockGetenvCall) GetArgs() RunEnvMockGetenvArgs {
	raw := c.RawArgs()
	return RunEnvMockGetenvArgs{
		Key: raw[0].(string),
	}
}

// Return specifies the typed values the mock should return.
func (c *RunEnvMockGetenvCall) Return(result0 string) {
	c.DependencyCall.Return(result0)
}

type RunEnvMockGetenvMethod struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *RunEnvMockGetenvMethod) ArgsEqual(key string) *RunEnvMockGetenvCall {
	call := m.DependencyMethod.ArgsEqual(key)
	return &RunEnvMockGetenvCall{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *RunEnvMockGetenvMethod) ArgsShould(matchers ...any) *RunEnvMockGetenvCall {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &RunEnvMockGetenvCall{DependencyCall: call}
}

type RunEnvMockGetwdCall struct {
	*_imptest.DependencyCall
}

// Return specifies the typed values the mock should return.
func (c *RunEnvMockGetwdCall) Return(result0 string, result1 error) {
	c.DependencyCall.Return(result0, result1)
}

type RunEnvMockPrintfArgs struct {
	Format string
	Args   []any
}

type RunEnvMockPrintfCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *RunEnvMockPrintfCall) GetArgs() RunEnvMockPrintfArgs {
	raw := c.RawArgs()
	return RunEnvMockPrintfArgs{
		Format: raw[0].(string),
		Args:   raw[1].([]any),
	}
}

type RunEnvMockPrintfMethod struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *RunEnvMockPrintfMethod) ArgsEqual(format string, args ...any) *RunEnvMockPrintfCall {
	callArgs := []any{format}
	for _, v := range args {
		callArgs = append(callArgs, v)
	}
	call := m.DependencyMethod.ArgsEqual(callArgs...)
	return &RunEnvMockPrintfCall{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *RunEnvMockPrintfMethod) ArgsShould(matchers ...any) *RunEnvMockPrintfCall {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &RunEnvMockPrintfCall{DependencyCall: call}
}

type RunEnvMockPrintlnArgs struct {
	Args []any
}

type RunEnvMockPrintlnCall struct {
	*_imptest.DependencyCall
}

// GetArgs returns the typed arguments for this call.
func (c *RunEnvMockPrintlnCall) GetArgs() RunEnvMockPrintlnArgs {
	raw := c.RawArgs()
	return RunEnvMockPrintlnArgs{
		Args: raw[0].([]any),
	}
}

type RunEnvMockPrintlnMethod struct {
	*_imptest.DependencyMethod
}

// ArgsEqual waits for a call with exactly the specified arguments.
func (m *RunEnvMockPrintlnMethod) ArgsEqual(args ...any) *RunEnvMockPrintlnCall {
	callArgs := []any{}
	for _, v := range args {
		callArgs = append(callArgs, v)
	}
	call := m.DependencyMethod.ArgsEqual(callArgs...)
	return &RunEnvMockPrintlnCall{DependencyCall: call}
}

// ArgsShould waits for a call with arguments matching the given matchers.
func (m *RunEnvMockPrintlnMethod) ArgsShould(matchers ...any) *RunEnvMockPrintlnCall {
	call := m.DependencyMethod.ArgsShould(matchers...)
	return &RunEnvMockPrintlnCall{DependencyCall: call}
}

type RunEnvMockStdoutCall struct {
	*_imptest.DependencyCall
}

// Return specifies the typed values the mock should return.
func (c *RunEnvMockStdoutCall) Return(result0 io.Writer) {
	c.DependencyCall.Return(result0)
}

type RunEnvMockSupportsSignalsCall struct {
	*_imptest.DependencyCall
}

// Return specifies the typed values the mock should return.
func (c *RunEnvMockSupportsSignalsCall) Return(result0 bool) {
	c.DependencyCall.Return(result0)
}

// MockRunEnv creates a mock RunEnv and returns (mock, expectation handle).
func MockRunEnv(t _imptest.TestReporter) (core.RunEnv, *RunEnvImp) {
	ctrl := _imptest.GetOrCreateImp(t)
	imp := &RunEnvImp{
		Args:            _imptest.NewDependencyMethod(ctrl, "Args"),
		Printf:          newRunEnvMockPrintfMethod(_imptest.NewDependencyMethod(ctrl, "Printf")),
		Println:         newRunEnvMockPrintlnMethod(_imptest.NewDependencyMethod(ctrl, "Println")),
		Exit:            newRunEnvMockExitMethod(_imptest.NewDependencyMethod(ctrl, "Exit")),
		Stdout:          _imptest.NewDependencyMethod(ctrl, "Stdout"),
		SupportsSignals: _imptest.NewDependencyMethod(ctrl, "SupportsSignals"),
		Getenv:          newRunEnvMockGetenvMethod(_imptest.NewDependencyMethod(ctrl, "Getenv")),
		Getwd:           _imptest.NewDependencyMethod(ctrl, "Getwd"),
		BinaryName:      _imptest.NewDependencyMethod(ctrl, "BinaryName"),
	}
	imp.Eventually = &RunEnvImpEventually{
		Args:            _imptest.NewDependencyMethod(ctrl, "Args").AsEventually(),
		Printf:          newRunEnvMockPrintfMethod(_imptest.NewDependencyMethod(ctrl, "Printf").AsEventually()),
		Println:         newRunEnvMockPrintlnMethod(_imptest.NewDependencyMethod(ctrl, "Println").AsEventually()),
		Exit:            newRunEnvMockExitMethod(_imptest.NewDependencyMethod(ctrl, "Exit").AsEventually()),
		Stdout:          _imptest.NewDependencyMethod(ctrl, "Stdout").AsEventually(),
		SupportsSignals: _imptest.NewDependencyMethod(ctrl, "SupportsSignals").AsEventually(),
		Getenv:          newRunEnvMockGetenvMethod(_imptest.NewDependencyMethod(ctrl, "Getenv").AsEventually()),
		Getwd:           _imptest.NewDependencyMethod(ctrl, "Getwd").AsEventually(),
		BinaryName:      _imptest.NewDependencyMethod(ctrl, "BinaryName").AsEventually(),
	}
	mock := &mockRunEnvImpl{ctrl: ctrl}
	return mock, imp
}

type mockRunEnvImpl struct {
	ctrl *_imptest.Imp
}

// Args implements core.RunEnv.Args.
func (impl *mockRunEnvImpl) Args() []string {
	call := &_imptest.GenericCall{
		MethodName:   "Args",
		Args:         []any{},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 []string
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].([]string); ok {
			result1 = value
		}
	}

	return result1
}

// BinaryName implements core.RunEnv.BinaryName.
func (impl *mockRunEnvImpl) BinaryName() string {
	call := &_imptest.GenericCall{
		MethodName:   "BinaryName",
		Args:         []any{},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 string
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(string); ok {
			result1 = value
		}
	}

	return result1
}

// Exit implements core.RunEnv.Exit.
func (impl *mockRunEnvImpl) Exit(code int) {
	call := &_imptest.GenericCall{
		MethodName:   "Exit",
		Args:         []any{code},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

}

// Getenv implements core.RunEnv.Getenv.
func (impl *mockRunEnvImpl) Getenv(key string) string {
	call := &_imptest.GenericCall{
		MethodName:   "Getenv",
		Args:         []any{key},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 string
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(string); ok {
			result1 = value
		}
	}

	return result1
}

// Getwd implements core.RunEnv.Getwd.
func (impl *mockRunEnvImpl) Getwd() (string, error) {
	call := &_imptest.GenericCall{
		MethodName:   "Getwd",
		Args:         []any{},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 string
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(string); ok {
			result1 = value
		}
	}

	var result2 error
	if len(resp.ReturnValues) > 1 {
		if value, ok := resp.ReturnValues[1].(error); ok {
			result2 = value
		}
	}

	return result1, result2
}

// Printf implements core.RunEnv.Printf.
func (impl *mockRunEnvImpl) Printf(format string, args ...any) {
	callArgs := []any{format}
	for _, v := range args {
		callArgs = append(callArgs, v)
	}
	call := &_imptest.GenericCall{
		MethodName:   "Printf",
		Args:         callArgs,
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

}

// Println implements core.RunEnv.Println.
func (impl *mockRunEnvImpl) Println(args ...any) {
	callArgs := []any{}
	for _, v := range args {
		callArgs = append(callArgs, v)
	}
	call := &_imptest.GenericCall{
		MethodName:   "Println",
		Args:         callArgs,
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

}

// Stdout implements core.RunEnv.Stdout.
func (impl *mockRunEnvImpl) Stdout() io.Writer {
	call := &_imptest.GenericCall{
		MethodName:   "Stdout",
		Args:         []any{},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 io.Writer
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(io.Writer); ok {
			result1 = value
		}
	}

	return result1
}

// SupportsSignals implements core.RunEnv.SupportsSignals.
func (impl *mockRunEnvImpl) SupportsSignals() bool {
	call := &_imptest.GenericCall{
		MethodName:   "SupportsSignals",
		Args:         []any{},
		ResponseChan: make(chan _imptest.GenericResponse, 1),
	}
	impl.ctrl.CallChan <- call
	resp := <-call.ResponseChan
	if resp.Type == "panic" {
		panic(resp.PanicValue)
	}

	var result1 bool
	if len(resp.ReturnValues) > 0 {
		if value, ok := resp.ReturnValues[0].(bool); ok {
			result1 = value
		}
	}

	return result1
}

// newRunEnvMockExitMethod creates a typed method wrapper.
func newRunEnvMockExitMethod(dm *_imptest.DependencyMethod) *RunEnvMockExitMethod {
	return &RunEnvMockExitMethod{DependencyMethod: dm}
}

// newRunEnvMockGetenvMethod creates a typed method wrapper.
func newRunEnvMockGetenvMethod(dm *_imptest.DependencyMethod) *RunEnvMockGetenvMethod {
	return &RunEnvMockGetenvMethod{DependencyMethod: dm}
}

// newRunEnvMockPrintfMethod creates a typed method wrapper.
func newRunEnvMockPrintfMethod(dm *_imptest.DependencyMethod) *RunEnvMockPrintfMethod {
	return &RunEnvMockPrintfMethod{DependencyMethod: dm}
}

// newRunEnvMockPrintlnMethod creates a typed method wrapper.
func newRunEnvMockPrintlnMethod(dm *_imptest.DependencyMethod) *RunEnvMockPrintlnMethod {
	return &RunEnvMockPrintlnMethod{DependencyMethod: dm}
}
