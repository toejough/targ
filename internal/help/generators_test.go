// TEST-022: Help generators properties - validates root help with deregistered packages
// traces: ARCH-007, ARCH-003

package help_test

import (
	"bytes"
	"strings"
	"testing"

	. "github.com/onsi/gomega"
	"pgregory.net/rapid"

	"github.com/toejough/targ/internal/help"
)

func TestAutoGeneratedRootExamples(t *testing.T) {
	t.Parallel()

	t.Run("TargModeRootExamples", func(t *testing.T) {
		t.Parallel()
		g := NewWithT(t)

		var buf bytes.Buffer

		opts := help.RootHelpOpts{
			BinaryName:  "targ",
			Description: "Build tool",
			CommandGroups: []help.CommandGroup{
				{Source: "dev/", Commands: []help.Command{
					{Name: "build", Desc: "Build the project"},
					{Name: "test", Desc: "Run tests"},
				}},
			},
			Filter: help.TargFlagFilter{IsRoot: true},
		}

		help.WriteRootHelp(&buf, opts)
		output := buf.String()

		// Should have auto-generated examples using actual command names
		g.Expect(output).To(ContainSubstring("targ build"))
		g.Expect(output).To(ContainSubstring("targ build test"))
	})

	t.Run("BinaryModeRootExamples", func(t *testing.T) {
		t.Parallel()
		g := NewWithT(t)

		var buf bytes.Buffer

		opts := help.RootHelpOpts{
			BinaryName:  "myapp",
			Description: "My app",
			CommandGroups: []help.CommandGroup{
				{Source: "main.go", Commands: []help.Command{
					{Name: "greet", Desc: "Say hello"},
				}},
			},
			Filter: help.TargFlagFilter{IsRoot: true, BinaryMode: true},
		}

		help.WriteRootHelp(&buf, opts)
		output := buf.String()

		// Should use binary name
		g.Expect(output).To(ContainSubstring("myapp greet"))
		// Should NOT reference "targ"
		g.Expect(output).ToNot(ContainSubstring("targ"))
	})

	t.Run("UserExamplesReplace", func(t *testing.T) {
		t.Parallel()
		g := NewWithT(t)

		var buf bytes.Buffer

		opts := help.RootHelpOpts{
			BinaryName:  "targ",
			Description: "Build tool",
			Examples: []help.Example{
				{Title: "Custom", Code: "targ custom-thing"},
			},
			Filter: help.TargFlagFilter{IsRoot: true},
		}

		help.WriteRootHelp(&buf, opts)
		output := buf.String()

		// User examples should replace auto-generated ones
		g.Expect(output).To(ContainSubstring("targ custom-thing"))
	})
}

func TestAutoGeneratedTargetExamples(t *testing.T) {
	t.Parallel()

	t.Run("TargetWithPositionalAndFlags", func(t *testing.T) {
		t.Parallel()
		g := NewWithT(t)

		var buf bytes.Buffer

		opts := help.TargetHelpOpts{
			BinaryName:  "targ",
			Name:        "deploy",
			Description: "Deploy the app",
			Flags: []help.Flag{
				{Long: "--env", Desc: "Environment", Placeholder: "ENV"},
				{Long: "--port", Desc: "Port number", Placeholder: "N"},
				{Long: "--dry-run", Desc: "Dry run"},
			},
			Filter: help.TargFlagFilter{IsRoot: false},
		}

		help.WriteTargetHelp(&buf, opts)
		output := buf.String()

		// Should have auto-generated example with flags
		g.Expect(output).To(ContainSubstring("targ deploy"))
		g.Expect(output).To(ContainSubstring("--env"))
	})

	t.Run("DurationPlaceholderProducesExampleValue", func(t *testing.T) {
		t.Parallel()
		g := NewWithT(t)

		var buf bytes.Buffer

		opts := help.TargetHelpOpts{
			BinaryName:  "targ",
			Name:        "wait",
			Description: "Wait for a duration",
			Flags: []help.Flag{
				{Long: "--timeout", Desc: "Timeout", Placeholder: "duration"},
			},
			Filter: help.TargFlagFilter{IsRoot: false},
		}

		help.WriteTargetHelp(&buf, opts)
		output := buf.String()

		g.Expect(output).To(ContainSubstring("targ wait"))
		g.Expect(output).To(ContainSubstring("30s"))
	})

	t.Run("BackoffPlaceholderProducesExampleValue", func(t *testing.T) {
		t.Parallel()
		g := NewWithT(t)

		var buf bytes.Buffer

		opts := help.TargetHelpOpts{
			BinaryName:  "targ",
			Name:        "retry",
			Description: "Retry with backoff",
			Flags: []help.Flag{
				{Long: "--backoff", Desc: "Backoff config", Placeholder: "d,m"},
			},
			Filter: help.TargFlagFilter{IsRoot: false},
		}

		help.WriteTargetHelp(&buf, opts)
		output := buf.String()

		g.Expect(output).To(ContainSubstring("targ retry"))
		g.Expect(output).To(ContainSubstring("1s,2.0"))
	})

	t.Run("TargetWithNoFlags", func(t *testing.T) {
		t.Parallel()
		g := NewWithT(t)

		var buf bytes.Buffer

		opts := help.TargetHelpOpts{
			BinaryName:  "targ",
			Name:        "clean",
			Description: "Clean build artifacts",
			Filter:      help.TargFlagFilter{IsRoot: false},
		}

		help.WriteTargetHelp(&buf, opts)
		output := buf.String()

		// Minimal example, just the command
		g.Expect(output).To(ContainSubstring("targ clean"))
	})

	t.Run("UserExamplesReplaceTargetExamples", func(t *testing.T) {
		t.Parallel()
		g := NewWithT(t)

		var buf bytes.Buffer

		opts := help.TargetHelpOpts{
			BinaryName:  "targ",
			Name:        "deploy",
			Description: "Deploy",
			Examples: []help.Example{
				{Title: "Deploy to prod", Code: "targ deploy --env production"},
			},
			Filter: help.TargFlagFilter{IsRoot: false},
		}

		help.WriteTargetHelp(&buf, opts)
		output := buf.String()

		g.Expect(output).To(ContainSubstring("Deploy to prod"))
	})
}

func TestProperty_WriteRootHelpWithDeregisteredPackages(t *testing.T) {
	t.Parallel()

	rapid.Check(t, func(t *rapid.T) {
		g := NewWithT(t)

		count := rapid.IntRange(1, 4).Draw(t, "count")

		pkgs := make([]string, 0, count)

		for range count {
			pkg := rapid.StringMatching(`[a-z]+\.[a-z]+/[a-z0-9-]+/[a-z0-9-]+`).Draw(t, "pkg")
			pkgs = append(pkgs, pkg)
		}

		var buf strings.Builder

		help.WriteRootHelp(&buf, help.RootHelpOpts{
			BinaryName:           "targ",
			Description:          "Test description",
			DeregisteredPackages: pkgs,
		})

		output := buf.String()

		g.Expect(output).To(ContainSubstring("Deregistered packages"))

		for _, pkg := range pkgs {
			g.Expect(output).To(ContainSubstring(pkg))
		}
	})
}
